---
layout: closure
title: Serialize closures | www.opis.io
keywords: php, closure, serialization, serializable closure, anonymous functions
description: Learn how to wrap a closure and make it serializable
active: serialize
---
<h1><strong>Serialize closures</strong></h1>

<p>
    If you ever used closures then you probably know that closures are not serializable. Trying to serialize
    a closure will result into an exception:
</p>

{% highlight php  %}
Fatal error: Uncaught exception 'Exception' with message 'Serialization of 'Closure' is not allowed'
{% endhighlight %}

<p>
    The solution for overcoming this problem is to wrap the closure into an <code>Opis\Closure\SerializableClosure</code> object,
    then serialize the wrapper object using the standard <code>serialize</code>.
</p>

{% highlight php startinline %}
use Opis\Closure\SerializableClosure;

// Recursive factorial closure
$factorial = function ($n) use (&$factorial) {
  return $n <= 1 ? 1 : $factorial($n - 1) * $n;
};

// Wrap the closure
$wrapper = new SerializableClosure($factorial);
// Now it can be serialized
$serialized = serialize($wrapper);
{% endhighlight %}

{% include subtitle.html value="Unserialize closures" %}

<p>
    Closure unserialization is done using the standard <code>unserialize</code> function.
    Once the wrapper was unserialized, you can directly invoke the wrapper, or you can extract the
    serialized closure by calling the <code>getClosure</code> method.
</p>

{% highlight php startinline %}
// Unserialize the closure
$wrapper = unserialize($serialized);

// You can directly invoke the wrapper...
echo $wrapper(5); //> 120

// Or, the recommended way, extract the closure object
$closure = $wrapper->getClosure();

echo $closure(5); //> 120
{% endhighlight %}

<p>
    Due to the fact that <strong>Opis Closure</strong> doesn't use <code>eval</code>
    in the serialization-deserialization process, all closures can be serialized and unserialized
    an infinite amount of times.
</p>

{% highlight php startinline %}
// Once again, but this time using the previously unserialized closure
$wrapper = new SerializableClosure($closure);
$serialized = serialize($wrapper);
$wrapper = unserialize($serialized);
$closure = $wrapper->getClosure();

// Now watch this...
echo $closure(5); //> 120
// It worked!
{% endhighlight %}

{% include subtitle.html value="The <em>unserializeData</em> method" h=4 %}

<p>
    If you are planning to support PHP 5.3, then you should be aware that there is a
    <a href="https://bugs.php.net/bug.php?id=36424" rel="nofollow" target="_blank">bug</a> (fixed in PHP 5.4.0)
    that will prevent <strong>Opis Closure</strong> to work properly in <a href="/closure/context.html">certain situations</a>.
</p>
<p>
    This problem can be overcome by using the <code>unserializeData</code> static method of the <code>Opis\Closure\SerializableClosure</code>
    class, which is just a wrapper for the <code>unserialize</code> function, that will somehow fix the previously mentioned bug.
</p>

{% highlight php startinline %}
// Unserialize the closure
$wrapper = SerializableClosure::unserializeData($serialized);

// Extract the closure object
$closure = $wrapper->getClosure();

echo $closure(5); //> 120
{% endhighlight %}

