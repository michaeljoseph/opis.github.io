---
layout: closure
title: Serialization context | Opis Closure
keywords: php, closure, serialization, serializable closure, anonymous functions
description: Learn about serialization context
active: context
---
<h1><strong>Serialization context</strong></h1>

<p>
    Sometimes, especially when we are working with serializable classes, it is desirable that an instance of a closure
    to be wrapped only by a single <code>Opis\Closure\SerializableClosure</code> class,
    in order to avoid multiple serialization of the same closure instance. Let's take the following example:
</p>

{% highlight php startinline %}
use Opis\Closure\SerializableClosure;

$function = function(){
    return "Hello World";
};

$collection = array(
    'a' => new SerializableClosure($function),
    'b' => new SerializableClosure($function),
);

//Serialize
$collection = serialize($collection);
//Unserialize
$collection = unserialize($collection);

$a = $collection['a']->getClosure();
$b = $collection['b']->getClosure();

//Prints FALSE
print $a === $b ? 'TRUE' : 'FALSE';
{% endhighlight %}

<p>
    As we can see, in the above example, even though the same closure instance was serialized, after the deserialization,
    two different instances of the same closure were created.
</p>
<p>
    This happened because the same closure was wrapped by two different <code>Opis\Closure\SerializableClosure</code>
    objects and therefore, when those objects were deserialized and the closures extracted, resulted two distinct closure instances.
</p>
<p>
    Avoiding this kind of situations is done by serializing closures <em>in context</em>:
</p>

{% highlight php startinline %}
use Opis\Closure\SerializableClosure;

$function = function(){
    return "Hello World";
};

SerializableClosure::enterContext();

$collection = array(
    'a' => SerializableClosure::from($function),
    'b' => SerializableClosure::from($function),
);

SerializableClosure::exitContext();

//Serialize
$collection = serialize($collection);
//Unserialize
$collection = SerializableClosure::unserializeData($collection);

$a = $collection['a']->getClosure();
$b = $collection['b']->getClosure();

//Prints TRUE
print $a === $b ? 'TRUE' : 'FALSE';
{% endhighlight %}

{% include subtitle.html value="The <em>enterContext</em> method" h=4 %}

<p>
    If a <em>serialization context</em> wasn't allready created by a previous call to this method, then a new
    <em>serialization context</em> is created. Each <em>serialization context</em> has an associated list of serialized
    closures and an internal counter which is incremented each time this method is called.
</p>

<p>
    Each call to this method must have a matching call to <code>Opis\Closure\SerializableClosure::exitContext</code> method.
</p>

{% include subtitle.html value="The <em>from</em> method" h=4 %}

<p>
    Wraps a given closure inside a <code>Opis\Closure\SerializableClosure</code> object,
    keeping a record of all closures that were wrapped in the current <em>serialization context</em>.
    When calling this method, if a closure was already wrapped, the coresponding
    <code>Opis\Closure\SerializableClosure</code> object will be returned. 
</p>

<p>
    This method can be used even if a <em>serialization context</em> wasn't created at call time.
</p>

{% include subtitle.html value="The <em>exitContext</em> method" h=4 %}

<p>
    Decrements the internal counter of the current <em>serialization context</em>, if any.
    When the counter reaches to zero, the current <em>serialization context</em> is destroyed.
</p>
